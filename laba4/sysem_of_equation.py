# -*- coding: utf-8 -*-
"""Sysem_of_equation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11zchEUMa5Tcr5tjCwJrvZw2xRTSK_Han
"""

import numpy as np
import sympy as sp
import copy

def get_jacobian(J,args,x_vector):
  J_cur=J.subs(list(zip(args,x_vector)))
  return J_cur.norm()

def get_jacobi_matrix(funcs_vector,args):
  J = sp.zeros(len(funcs_vector),len(args))
  for i, func in enumerate(funcs_vector):
    for j, arg in enumerate(args):
      J[i,j]=sp.diff(func,arg)
  return J

def check_converge(J,args,x_vector):
  if get_jacobian(J,args,x_vector)>1.0:
    return "Not converdge"
  else:
    return "Converdge"

def newton_method(funcs_vector,args,args_val):
  x_cur=sp.Matrix([args_val[0],args_val[1]])
  x_prev=x_cur
  J=get_jacobi_matrix(funcs_vector,args)
  J_inv=J.inv()

  x_prev=x_cur
  iter_num=0
  delta=1
  while delta>0.0001:
    J_cur=J_inv.subs(list(zip(args,x_prev)))
    vector_prev=funcs_vector.subs(list(zip(args,x_prev)))
    x_cur=x_prev-J_cur*vector_prev
    delta=abs(x_cur-x_prev)
    delta=delta.norm()
    x_prev=x_cur
    iter_num+=1
  return x_cur,delta,iter_num

x = sp.symbols('x')
y = sp.symbols('y')
f1=sp.tan(x*y+0.3)-x
f2=0.5*x**2+2*y**2-1
x0=1.0
y0=0.5
args_val=[x0,y0]
x_cur=sp.Matrix([x0,y0])
x_prev=sp.Matrix([0,0])
funcs_vector=sp.Matrix([f1,f2])
args=[x,y]

newton_method(funcs_vector,args,args_val)



def simple_iteration_method(funcs_vector,args,args_val):
  x_cur=sp.Matrix([args_val[0],args_val[1]])
  x_prev=x_cur
  J=get_jacobi_matrix(funcs_vector,args)
  print(check_converge(J,args,x_cur))
  delta=0.1
  iter_num=0
  while delta>0.0001:
    x_cur=funcs_vector.subs(list(zip(args,x_prev)))
    delta=abs(x_cur-x_prev)
    delta=delta.norm()
    x_prev=x_cur
    iter_num+=1
    if iter_num>200:
      print("Error")
      return 0
  return x_cur,delta,iter_num

x = sp.symbols('x')
y = sp.symbols('y')
f1=sp.tan(x*y+0.3)
f2=sp.sqrt((1-0.5*x**2)/2)
x0=6
y0=3
args_val=[x0,y0]
x_cur=sp.Matrix([x0,y0])
x_prev=x_cur
funcs_vector=sp.Matrix([f1,f2])
args=[x,y]

simple_iteration_method(funcs_vector,args,args_val)





def solve_system_newton(funcs_vector,args,args_val):
  x_val,accuracy,num_iter=newton_method(funcs_vector,args,args_val)
  x_vals=[]
  for x in x_val:
    x_vals.append(round(x,4))
  print(f"x = {x_vals}\naccuracy={round(accuracy,10)}\nNumber of iteration = {num_iter}")
  return x_val

x = sp.symbols('x')
y = sp.symbols('y')
f1=sp.tan(x*y+0.4)-x
f2=0.6*x**2+2*y**2-1
x0=12
y0=12
args_val=[x0,y0]
x_cur=sp.Matrix([x0,y0])
x_prev=sp.Matrix([0,0])
funcs_vector=sp.Matrix([f1,f2])
args=[x,y]

x_val_1 = solve_system_newton(funcs_vector,args,args_val)

x = sp.symbols('x')
y = sp.symbols('y')
f1=sp.tan(x*y+0.401)-x
f2=0.61*x**1.999+2*y**2-1.01
x0=12
y0=12
args_val=[x0,y0]
x_cur=sp.Matrix([x0,y0])
x_prev=sp.Matrix([0,0])
funcs_vector=sp.Matrix([f1,f2])
args=[x,y]

x_val_2 = solve_system_newton(funcs_vector,args,args_val)

error=(x_val_1-x_val_2).norm()
print(f"Error = {round(error,7)}")



def solve_system_simple_itetation(funcs_vector,args,args_val):
  x_val,accuracy,num_iter=simple_iteration_method(funcs_vector,args,args_val)
  x_vals=[]
  for x in x_val:
    x_vals.append(round(x,4))
  print(f"x = {x_vals}\naccuracy={round(accuracy,10)}\nNumber of iteration = {num_iter}")
  return x_val

x = sp.symbols('x')
y = sp.symbols('y')
f1=sp.tan(x*y)
f2=np.sqrt(0.5)
x0=1.0
y0=0.7
args_val=[x0,y0]
x_cur=sp.Matrix([x0,y0])
x_prev=sp.Matrix([0,0])
funcs_vector=sp.Matrix([f1,f2])
args=[x,y]

solve_system_simple_itetation(funcs_vector,args,args_val)